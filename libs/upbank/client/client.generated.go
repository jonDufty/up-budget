// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	Bearer_authScopes = "bearer_auth.Scopes"
)

// Provides information about an Up bank account.
type AccountResource struct {
	Attributes struct {
		// The bank account type of this account.
		AccountType interface{} `json:"accountType"`

		// The available balance of the account, taking into account any amounts
		// that are currently on hold.
		Balance struct {
			// The ISO 4217 currency code.
			CurrencyCode string `json:"currencyCode"`

			// The amount of money, formatted as a string in the relevant currency.
			// For example, for an Australian dollar value of $10.56, this field will
			// be `"10.56"`. The currency symbol is not included in the string.
			Value string `json:"value"`

			// The amount of money in the smallest denomination for the currency, as a
			// 64-bit integer.  For example, for an Australian dollar value of $10.56,
			// this field will be `1056`.
			ValueInBaseUnits int `json:"valueInBaseUnits"`
		} `json:"balance"`

		// The date-time at which this account was first opened.
		CreatedAt time.Time `json:"createdAt"`

		// The name associated with the account in the Up application.
		DisplayName string `json:"displayName"`

		// The ownership structure for this account.
		OwnershipType interface{} `json:"ownershipType"`
	} `json:"attributes"`

	// The unique identifier for this account.
	Id    string `json:"id"`
	Links *struct {
		// The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty"`
	Relationships struct {
		Transactions struct {
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"transactions"`
	} `json:"relationships"`

	// The type of this resource: `accounts`
	Type string `json:"type"`
}

// Specifies the type of bank account. Currently returned values are `SAVER`
// and `TRANSACTIONAL`.
type AccountTypeEnum = interface{}

// Provides information about an instant reimbursement in the form of
// cashback.
type CashbackObject struct {
	// The total amount of cashback paid, represented as a positive value.
	Amount struct {
		// The ISO 4217 currency code.
		CurrencyCode string `json:"currencyCode"`

		// The amount of money, formatted as a string in the relevant currency.
		// For example, for an Australian dollar value of $10.56, this field will
		// be `"10.56"`. The currency symbol is not included in the string.
		Value string `json:"value"`

		// The amount of money in the smallest denomination for the currency, as a
		// 64-bit integer.  For example, for an Australian dollar value of $10.56,
		// this field will be `1056`.
		ValueInBaseUnits int `json:"valueInBaseUnits"`
	} `json:"amount"`

	// A brief description of why this cashback was paid.
	Description string `json:"description"`
}

// Uniquely identifies a category in the API.
type CategoryInputResourceIdentifier struct {
	// The unique identifier of the category, as returned by the `/categories`
	// endpoint.
	Id string `json:"id"`

	// The type of this resource: `categories`
	Type string `json:"type"`
}

// Provides information about a category and its ancestry.
type CategoryResource struct {
	Attributes struct {
		// The name of this category as seen in the Up application.
		Name string `json:"name"`
	} `json:"attributes"`

	// The unique identifier for this category. This is a human-readable but
	// URL-safe value.
	Id    string `json:"id"`
	Links *struct {
		// The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty"`
	Relationships struct {
		Children struct {
			Data []struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"children"`
		Parent struct {
			Data *struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"parent"`
	} `json:"relationships"`

	// The type of this resource: `categories`
	Type string `json:"type"`
}

// Request to create a new webhook. This currently only requires a `url`
// attribute.
type CreateWebhookRequest struct {
	// The webhook resource to create.
	Data struct {
		Attributes struct {
			// An optional description for this webhook, up to 64 characters in
			// length.
			Description *string `json:"description"`

			// The URL that this webhook should post events to. This must be a valid
			// HTTP or HTTPS URL that does not exceed 300 characters in length.
			Url string `json:"url"`
		} `json:"attributes"`
	} `json:"data"`
}

// Successful response after creating a webhook.
type CreateWebhookResponse struct {
	// The webhook that was created.
	Data struct {
		Attributes struct {
			// The date-time at which this webhook was created.
			CreatedAt time.Time `json:"createdAt"`

			// An optional description that was provided at the time the webhook was
			// created.
			Description *string `json:"description"`

			// A shared secret key used to sign all webhook events sent to the
			// configured webhook URL. This field is returned only once, upon the
			// initial creation of the webhook. If lost, create a new webhook and
			// delete this webhook.
			//
			// The webhook URL receives a request with a
			// `X-Up-Authenticity-Signature` header, which is the SHA-256 HMAC of
			// the entire raw request body signed using this `secretKey`. It is
			// advised to compute and check this signature to verify the
			// authenticity of requests sent to the webhook URL. See
			// [Handling webhook events](#callback_post_webhookURL) for full
			// details.
			SecretKey *string `json:"secretKey,omitempty"`

			// The URL that this webhook is configured to `POST` events to.
			Url string `json:"url"`
		} `json:"attributes"`

		// The unique identifier for this webhook.
		Id    string `json:"id"`
		Links *struct {
			// The canonical link to this resource within the API.
			Self string `json:"self"`
		} `json:"links,omitempty"`
		Relationships struct {
			Logs struct {
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"logs"`
		} `json:"relationships"`

		// The type of this resource: `webhooks`
		Type string `json:"type"`
	} `json:"data"`
}

// Provides information about an error processing a request.
type ErrorObject struct {
	// A detailed description of this error. This should be considered unique
	// to individual occurrences of an error and subject to change. It is
	// useful for debugging purposes.
	Detail string `json:"detail"`

	// If applicable, location in the request that this error relates to. This
	// may be a parameter in the query string, or a an attribute in the
	// request body.
	Source *struct {
		// If this error relates to a query parameter, the name of the
		// parameter.
		Parameter *string `json:"parameter,omitempty"`

		// If this error relates to an attribute in the request body, a
		// rfc-6901 JSON pointer to the attribute.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// The HTTP status code associated with this error. This can also be
	// obtained from the response headers. The status indicates the broad type
	// of error according to HTTP semantics.
	Status string `json:"status"`

	// A short description of this error. This should be stable across
	// multiple occurrences of this type of error and typically expands on the
	// reason for the status code.
	Title string `json:"title"`
}

// Generic error response that returns one or more errors.
type ErrorResponse struct {
	// The list of errors returned in this response.
	Errors []ErrorObject `json:"errors"`
}

// Successful response to get a single account.
type GetAccountResponse struct {
	// The account returned in this response.
	Data struct {
		Attributes struct {
			// The bank account type of this account.
			AccountType interface{} `json:"accountType"`

			// The available balance of the account, taking into account any amounts
			// that are currently on hold.
			Balance struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"balance"`

			// The date-time at which this account was first opened.
			CreatedAt time.Time `json:"createdAt"`

			// The name associated with the account in the Up application.
			DisplayName string `json:"displayName"`

			// The ownership structure for this account.
			OwnershipType interface{} `json:"ownershipType"`
		} `json:"attributes"`

		// The unique identifier for this account.
		Id    string `json:"id"`
		Links *struct {
			// The canonical link to this resource within the API.
			Self string `json:"self"`
		} `json:"links,omitempty"`
		Relationships struct {
			Transactions struct {
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"transactions"`
		} `json:"relationships"`

		// The type of this resource: `accounts`
		Type string `json:"type"`
	} `json:"data"`
}

// Successful response to get a single category and its ancestry.
type GetCategoryResponse struct {
	// The category returned in this response.
	Data struct {
		Attributes struct {
			// The name of this category as seen in the Up application.
			Name string `json:"name"`
		} `json:"attributes"`

		// The unique identifier for this category. This is a human-readable but
		// URL-safe value.
		Id    string `json:"id"`
		Links *struct {
			// The canonical link to this resource within the API.
			Self string `json:"self"`
		} `json:"links,omitempty"`
		Relationships struct {
			Children struct {
				Data []struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `categories`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"children"`
			Parent struct {
				Data *struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `categories`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"parent"`
		} `json:"relationships"`

		// The type of this resource: `categories`
		Type string `json:"type"`
	} `json:"data"`
}

// Successful response to get a single transaction.
type GetTransactionResponse struct {
	// The transaction returned in this response.
	Data struct {
		Attributes struct {
			// The amount of this transaction in Australian dollars. For
			// transactions that were once `HELD` but are now `SETTLED`, refer to
			// the `holdInfo` field for the original `amount` the transaction was
			// `HELD` at.
			Amount struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"amount"`

			// If all or part of this transaction was instantly reimbursed in the
			// form of cashback, details of the reimbursement.
			Cashback *struct {
				// The total amount of cashback paid, represented as a positive value.
				Amount struct {
					// The ISO 4217 currency code.
					CurrencyCode string `json:"currencyCode"`

					// The amount of money, formatted as a string in the relevant currency.
					// For example, for an Australian dollar value of $10.56, this field will
					// be `"10.56"`. The currency symbol is not included in the string.
					Value string `json:"value"`

					// The amount of money in the smallest denomination for the currency, as a
					// 64-bit integer.  For example, for an Australian dollar value of $10.56,
					// this field will be `1056`.
					ValueInBaseUnits int `json:"valueInBaseUnits"`
				} `json:"amount"`

				// A brief description of why this cashback was paid.
				Description string `json:"description"`
			} `json:"cashback"`

			// The date-time at which this transaction was first encountered.
			CreatedAt time.Time `json:"createdAt"`

			// A short description for this transaction. Usually the merchant name
			// for purchases.
			Description string `json:"description"`

			// The foreign currency amount of this transaction. This field will be
			// `null` for domestic transactions. The amount was converted to the AUD
			// amount reflected in the `amount` of this transaction. Refer to the
			// `holdInfo` field for the original `foreignAmount` the transaction was
			// `HELD` at.
			ForeignAmount *struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"foreignAmount"`

			// If this transaction is currently in the `HELD` status, or was ever in
			// the `HELD` status, the `amount` and `foreignAmount` of the
			// transaction while `HELD`.
			HoldInfo *struct {
				// The amount of this transaction while in the `HELD` status, in
				// Australian dollars.
				Amount struct {
					// The ISO 4217 currency code.
					CurrencyCode string `json:"currencyCode"`

					// The amount of money, formatted as a string in the relevant currency.
					// For example, for an Australian dollar value of $10.56, this field will
					// be `"10.56"`. The currency symbol is not included in the string.
					Value string `json:"value"`

					// The amount of money in the smallest denomination for the currency, as a
					// 64-bit integer.  For example, for an Australian dollar value of $10.56,
					// this field will be `1056`.
					ValueInBaseUnits int `json:"valueInBaseUnits"`
				} `json:"amount"`

				// The foreign currency amount of this transaction while in the `HELD`
				// status. This field will be `null` for domestic transactions. The amount
				// was converted to the AUD amount reflected in the `amount` field.
				ForeignAmount *struct {
					// The ISO 4217 currency code.
					CurrencyCode string `json:"currencyCode"`

					// The amount of money, formatted as a string in the relevant currency.
					// For example, for an Australian dollar value of $10.56, this field will
					// be `"10.56"`. The currency symbol is not included in the string.
					Value string `json:"value"`

					// The amount of money in the smallest denomination for the currency, as a
					// 64-bit integer.  For example, for an Australian dollar value of $10.56,
					// this field will be `1056`.
					ValueInBaseUnits int `json:"valueInBaseUnits"`
				} `json:"foreignAmount"`
			} `json:"holdInfo"`

			// Boolean flag set to true on transactions that support the use of
			// categories.
			IsCategorizable bool `json:"isCategorizable"`

			// Attached message for this transaction, such as a payment message, or a
			// transfer note.
			Message *string `json:"message"`

			// The original, unprocessed text of the transaction. This is often not
			// a perfect indicator of the actual merchant, but it is useful for
			// reconciliation purposes in some cases.
			RawText *string `json:"rawText"`

			// Details of how this transaction was rounded-up. If no Round Up was
			// applied this field will be `null`.
			RoundUp *struct {
				// The total amount of this Round Up, including any boosts, represented as
				// a negative value.
				Amount struct {
					// The ISO 4217 currency code.
					CurrencyCode string `json:"currencyCode"`

					// The amount of money, formatted as a string in the relevant currency.
					// For example, for an Australian dollar value of $10.56, this field will
					// be `"10.56"`. The currency symbol is not included in the string.
					Value string `json:"value"`

					// The amount of money in the smallest denomination for the currency, as a
					// 64-bit integer.  For example, for an Australian dollar value of $10.56,
					// this field will be `1056`.
					ValueInBaseUnits int `json:"valueInBaseUnits"`
				} `json:"amount"`

				// The portion of the Round Up `amount` owing to boosted Round Ups,
				// represented as a negative value. If no boost was added to the Round Up
				// this field will be `null`.
				BoostPortion *struct {
					// The ISO 4217 currency code.
					CurrencyCode string `json:"currencyCode"`

					// The amount of money, formatted as a string in the relevant currency.
					// For example, for an Australian dollar value of $10.56, this field will
					// be `"10.56"`. The currency symbol is not included in the string.
					Value string `json:"value"`

					// The amount of money in the smallest denomination for the currency, as a
					// 64-bit integer.  For example, for an Australian dollar value of $10.56,
					// this field will be `1056`.
					ValueInBaseUnits int `json:"valueInBaseUnits"`
				} `json:"boostPortion"`
			} `json:"roundUp"`

			// The date-time at which this transaction settled. This field will be
			// `null` for transactions that are currently in the `HELD` status.
			SettledAt *time.Time `json:"settledAt"`

			// The current processing status of this transaction, according to
			// whether or not this transaction has settled or is still held.
			Status interface{} `json:"status"`
		} `json:"attributes"`

		// The unique identifier for this transaction.
		Id    string `json:"id"`
		Links *struct {
			// The canonical link to this resource within the API.
			Self string `json:"self"`
		} `json:"links,omitempty"`
		Relationships struct {
			Account struct {
				Data struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `accounts`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"account"`
			Category struct {
				Data *struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `categories`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related *string `json:"related,omitempty"`

					// The link to retrieve or modify linkage between this resources and the
					// related resource(s) in this relationship.
					Self string `json:"self"`
				} `json:"links,omitempty"`
			} `json:"category"`
			ParentCategory struct {
				Data *struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `categories`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"parentCategory"`
			Tags struct {
				Data []struct {
					// The label of the tag, which also acts as the tag’s unique identifier.
					Id string `json:"id"`

					// The type of this resource: `tags`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve or modify linkage between this resources and the
					// related resource(s) in this relationship.
					Self string `json:"self"`
				} `json:"links,omitempty"`
			} `json:"tags"`

			// If this transaction is a transfer between accounts, this relationship
			// will contain the account the transaction went to/came from. The
			// `amount` field can be used to determine the direction of the transfer.
			TransferAccount struct {
				Data *struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `accounts`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"transferAccount"`
		} `json:"relationships"`

		// The type of this resource: `transactions`
		Type string `json:"type"`
	} `json:"data"`
}

// Successful response to get a single webhook.
type GetWebhookResponse struct {
	// The webhook returned in this response.
	Data struct {
		Attributes struct {
			// The date-time at which this webhook was created.
			CreatedAt time.Time `json:"createdAt"`

			// An optional description that was provided at the time the webhook was
			// created.
			Description *string `json:"description"`

			// A shared secret key used to sign all webhook events sent to the
			// configured webhook URL. This field is returned only once, upon the
			// initial creation of the webhook. If lost, create a new webhook and
			// delete this webhook.
			//
			// The webhook URL receives a request with a
			// `X-Up-Authenticity-Signature` header, which is the SHA-256 HMAC of
			// the entire raw request body signed using this `secretKey`. It is
			// advised to compute and check this signature to verify the
			// authenticity of requests sent to the webhook URL. See
			// [Handling webhook events](#callback_post_webhookURL) for full
			// details.
			SecretKey *string `json:"secretKey,omitempty"`

			// The URL that this webhook is configured to `POST` events to.
			Url string `json:"url"`
		} `json:"attributes"`

		// The unique identifier for this webhook.
		Id    string `json:"id"`
		Links *struct {
			// The canonical link to this resource within the API.
			Self string `json:"self"`
		} `json:"links,omitempty"`
		Relationships struct {
			Logs struct {
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"logs"`
		} `json:"relationships"`

		// The type of this resource: `webhooks`
		Type string `json:"type"`
	} `json:"data"`
}

// Provides information about the amount at which a transaction was in the
// `HELD` status.
type HoldInfoObject struct {
	// The amount of this transaction while in the `HELD` status, in
	// Australian dollars.
	Amount struct {
		// The ISO 4217 currency code.
		CurrencyCode string `json:"currencyCode"`

		// The amount of money, formatted as a string in the relevant currency.
		// For example, for an Australian dollar value of $10.56, this field will
		// be `"10.56"`. The currency symbol is not included in the string.
		Value string `json:"value"`

		// The amount of money in the smallest denomination for the currency, as a
		// 64-bit integer.  For example, for an Australian dollar value of $10.56,
		// this field will be `1056`.
		ValueInBaseUnits int `json:"valueInBaseUnits"`
	} `json:"amount"`

	// The foreign currency amount of this transaction while in the `HELD`
	// status. This field will be `null` for domestic transactions. The amount
	// was converted to the AUD amount reflected in the `amount` field.
	ForeignAmount *struct {
		// The ISO 4217 currency code.
		CurrencyCode string `json:"currencyCode"`

		// The amount of money, formatted as a string in the relevant currency.
		// For example, for an Australian dollar value of $10.56, this field will
		// be `"10.56"`. The currency symbol is not included in the string.
		Value string `json:"value"`

		// The amount of money in the smallest denomination for the currency, as a
		// 64-bit integer.  For example, for an Australian dollar value of $10.56,
		// this field will be `1056`.
		ValueInBaseUnits int `json:"valueInBaseUnits"`
	} `json:"foreignAmount"`
}

// Successful response to get all accounts. This returns a paginated list of
// accounts, which can be scrolled by following the `prev` and `next` links
// if present.
type ListAccountsResponse struct {
	// The list of accounts returned in this response.
	Data  []AccountResource `json:"data"`
	Links struct {
		// The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next *string `json:"next"`

		// The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev *string `json:"prev"`
	} `json:"links"`
}

// Successful response to get all categories and their ancestry. The
// returned list is not paginated.
type ListCategoriesResponse struct {
	// The list of categories returned in this response.
	Data []CategoryResource `json:"data"`
}

// Successful response to get all tags. This returns a paginated list of
// tags, which can be scrolled by following the `prev` and `next` links if
// present.
type ListTagsResponse struct {
	// The list of tags returned in this response.
	Data  []TagResource `json:"data"`
	Links struct {
		// The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next *string `json:"next"`

		// The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev *string `json:"prev"`
	} `json:"links"`
}

// Successful response to get all transactions. This returns a paginated
// list of transactions, which can be scrolled by following the `prev` and
// `next` links if present.
type ListTransactionsResponse struct {
	// The list of transactions returned in this response.
	Data  []TransactionResource `json:"data"`
	Links struct {
		// The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next *string `json:"next"`

		// The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev *string `json:"prev"`
	} `json:"links"`
}

// Successful response to get all delivery logs for a webhook. This returns
// a paginated list of delivery logs, which can be scrolled by following the
// `next` and `prev` links if present.
type ListWebhookDeliveryLogsResponse struct {
	// The list of delivery logs returned in this response.
	Data  []WebhookDeliveryLogResource `json:"data"`
	Links struct {
		// The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next *string `json:"next"`

		// The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev *string `json:"prev"`
	} `json:"links"`
}

// Successful response to get all webhooks. This returns a paginated list of
// webhooks, which can be scrolled by following the `prev` and `next` links
// if present.
type ListWebhooksResponse struct {
	// The list of webhooks returned in this response.
	Data  []WebhookResource `json:"data"`
	Links struct {
		// The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next *string `json:"next"`

		// The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev *string `json:"prev"`
	} `json:"links"`
}

// Provides information about a value of money.
type MoneyObject struct {
	// The ISO 4217 currency code.
	CurrencyCode string `json:"currencyCode"`

	// The amount of money, formatted as a string in the relevant currency.
	// For example, for an Australian dollar value of $10.56, this field will
	// be `"10.56"`. The currency symbol is not included in the string.
	Value string `json:"value"`

	// The amount of money in the smallest denomination for the currency, as a
	// 64-bit integer.  For example, for an Australian dollar value of $10.56,
	// this field will be `1056`.
	ValueInBaseUnits int `json:"valueInBaseUnits"`
}

// Specifies the structure under which a bank account is owned. Currently
// returned values are `INDIVIDUAL` and `JOINT`.
type OwnershipTypeEnum = interface{}

// Basic ping response to verify authentication.
type PingResponse struct {
	Meta struct {
		// The unique identifier of the authenticated customer.
		Id string `json:"id"`

		// A cute emoji that represents the response status.
		StatusEmoji string `json:"statusEmoji"`
	} `json:"meta"`
}

// Provides information about how a Round Up was applied, such as whether or
// not a boost was included in the Round Up.
type RoundUpObject struct {
	// The total amount of this Round Up, including any boosts, represented as
	// a negative value.
	Amount struct {
		// The ISO 4217 currency code.
		CurrencyCode string `json:"currencyCode"`

		// The amount of money, formatted as a string in the relevant currency.
		// For example, for an Australian dollar value of $10.56, this field will
		// be `"10.56"`. The currency symbol is not included in the string.
		Value string `json:"value"`

		// The amount of money in the smallest denomination for the currency, as a
		// 64-bit integer.  For example, for an Australian dollar value of $10.56,
		// this field will be `1056`.
		ValueInBaseUnits int `json:"valueInBaseUnits"`
	} `json:"amount"`

	// The portion of the Round Up `amount` owing to boosted Round Ups,
	// represented as a negative value. If no boost was added to the Round Up
	// this field will be `null`.
	BoostPortion *struct {
		// The ISO 4217 currency code.
		CurrencyCode string `json:"currencyCode"`

		// The amount of money, formatted as a string in the relevant currency.
		// For example, for an Australian dollar value of $10.56, this field will
		// be `"10.56"`. The currency symbol is not included in the string.
		Value string `json:"value"`

		// The amount of money in the smallest denomination for the currency, as a
		// 64-bit integer.  For example, for an Australian dollar value of $10.56,
		// this field will be `1056`.
		ValueInBaseUnits int `json:"valueInBaseUnits"`
	} `json:"boostPortion"`
}

// Uniquely identifies a single tag in the API.
type TagInputResourceIdentifier struct {
	// The label of the tag, which also acts as the tag’s unique identifier.
	Id string `json:"id"`

	// The type of this resource: `tags`
	Type string `json:"type"`
}

// Provides information about a tag.
type TagResource struct {
	// The label of the tag, which also acts as the tag’s unique identifier.
	Id            string `json:"id"`
	Relationships struct {
		Transactions struct {
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"transactions"`
	} `json:"relationships"`

	// The type of this resource: `tags`
	Type string `json:"type"`
}

// TransactionResource defines model for TransactionResource.
type TransactionResource struct {
	Attributes struct {
		// The amount of this transaction in Australian dollars. For
		// transactions that were once `HELD` but are now `SETTLED`, refer to
		// the `holdInfo` field for the original `amount` the transaction was
		// `HELD` at.
		Amount struct {
			// The ISO 4217 currency code.
			CurrencyCode string `json:"currencyCode"`

			// The amount of money, formatted as a string in the relevant currency.
			// For example, for an Australian dollar value of $10.56, this field will
			// be `"10.56"`. The currency symbol is not included in the string.
			Value string `json:"value"`

			// The amount of money in the smallest denomination for the currency, as a
			// 64-bit integer.  For example, for an Australian dollar value of $10.56,
			// this field will be `1056`.
			ValueInBaseUnits int `json:"valueInBaseUnits"`
		} `json:"amount"`

		// If all or part of this transaction was instantly reimbursed in the
		// form of cashback, details of the reimbursement.
		Cashback *struct {
			// The total amount of cashback paid, represented as a positive value.
			Amount struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"amount"`

			// A brief description of why this cashback was paid.
			Description string `json:"description"`
		} `json:"cashback"`

		// The date-time at which this transaction was first encountered.
		CreatedAt time.Time `json:"createdAt"`

		// A short description for this transaction. Usually the merchant name
		// for purchases.
		Description string `json:"description"`

		// The foreign currency amount of this transaction. This field will be
		// `null` for domestic transactions. The amount was converted to the AUD
		// amount reflected in the `amount` of this transaction. Refer to the
		// `holdInfo` field for the original `foreignAmount` the transaction was
		// `HELD` at.
		ForeignAmount *struct {
			// The ISO 4217 currency code.
			CurrencyCode string `json:"currencyCode"`

			// The amount of money, formatted as a string in the relevant currency.
			// For example, for an Australian dollar value of $10.56, this field will
			// be `"10.56"`. The currency symbol is not included in the string.
			Value string `json:"value"`

			// The amount of money in the smallest denomination for the currency, as a
			// 64-bit integer.  For example, for an Australian dollar value of $10.56,
			// this field will be `1056`.
			ValueInBaseUnits int `json:"valueInBaseUnits"`
		} `json:"foreignAmount"`

		// If this transaction is currently in the `HELD` status, or was ever in
		// the `HELD` status, the `amount` and `foreignAmount` of the
		// transaction while `HELD`.
		HoldInfo *struct {
			// The amount of this transaction while in the `HELD` status, in
			// Australian dollars.
			Amount struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"amount"`

			// The foreign currency amount of this transaction while in the `HELD`
			// status. This field will be `null` for domestic transactions. The amount
			// was converted to the AUD amount reflected in the `amount` field.
			ForeignAmount *struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"foreignAmount"`
		} `json:"holdInfo"`

		// Boolean flag set to true on transactions that support the use of
		// categories.
		IsCategorizable bool `json:"isCategorizable"`

		// Attached message for this transaction, such as a payment message, or a
		// transfer note.
		Message *string `json:"message"`

		// The original, unprocessed text of the transaction. This is often not
		// a perfect indicator of the actual merchant, but it is useful for
		// reconciliation purposes in some cases.
		RawText *string `json:"rawText"`

		// Details of how this transaction was rounded-up. If no Round Up was
		// applied this field will be `null`.
		RoundUp *struct {
			// The total amount of this Round Up, including any boosts, represented as
			// a negative value.
			Amount struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"amount"`

			// The portion of the Round Up `amount` owing to boosted Round Ups,
			// represented as a negative value. If no boost was added to the Round Up
			// this field will be `null`.
			BoostPortion *struct {
				// The ISO 4217 currency code.
				CurrencyCode string `json:"currencyCode"`

				// The amount of money, formatted as a string in the relevant currency.
				// For example, for an Australian dollar value of $10.56, this field will
				// be `"10.56"`. The currency symbol is not included in the string.
				Value string `json:"value"`

				// The amount of money in the smallest denomination for the currency, as a
				// 64-bit integer.  For example, for an Australian dollar value of $10.56,
				// this field will be `1056`.
				ValueInBaseUnits int `json:"valueInBaseUnits"`
			} `json:"boostPortion"`
		} `json:"roundUp"`

		// The date-time at which this transaction settled. This field will be
		// `null` for transactions that are currently in the `HELD` status.
		SettledAt *time.Time `json:"settledAt"`

		// The current processing status of this transaction, according to
		// whether or not this transaction has settled or is still held.
		Status interface{} `json:"status"`
	} `json:"attributes"`

	// The unique identifier for this transaction.
	Id    string `json:"id"`
	Links *struct {
		// The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty"`
	Relationships struct {
		Account struct {
			Data struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `accounts`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"account"`
		Category struct {
			Data *struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related *string `json:"related,omitempty"`

				// The link to retrieve or modify linkage between this resources and the
				// related resource(s) in this relationship.
				Self string `json:"self"`
			} `json:"links,omitempty"`
		} `json:"category"`
		ParentCategory struct {
			Data *struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"parentCategory"`
		Tags struct {
			Data []struct {
				// The label of the tag, which also acts as the tag’s unique identifier.
				Id string `json:"id"`

				// The type of this resource: `tags`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve or modify linkage between this resources and the
				// related resource(s) in this relationship.
				Self string `json:"self"`
			} `json:"links,omitempty"`
		} `json:"tags"`

		// If this transaction is a transfer between accounts, this relationship
		// will contain the account the transaction went to/came from. The
		// `amount` field can be used to determine the direction of the transfer.
		TransferAccount struct {
			Data *struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `accounts`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"transferAccount"`
	} `json:"relationships"`

	// The type of this resource: `transactions`
	Type string `json:"type"`
}

// Specifies which stage of processing a transaction is currently at.
// Currently returned values are `HELD` and `SETTLED`. When a transaction is
// held, its account’s `availableBalance` is affected. When a transaction is
// settled, its account’s `currentBalance` is affected.
type TransactionStatusEnum = interface{}

// Request to update the category associated with a transaction.
type UpdateTransactionCategoryRequest struct {
	// The category to set on the transaction. Set this entire key to `null`
	// de-categorize a transaction.
	Data *struct {
		// The unique identifier of the category, as returned by the `/categories`
		// endpoint.
		Id string `json:"id"`

		// The type of this resource: `categories`
		Type string `json:"type"`
	} `json:"data"`
}

// Request to add or remove tags associated with a transaction.
type UpdateTransactionTagsRequest struct {
	// The tags to add to or remove from the transaction.
	Data []TagInputResourceIdentifier `json:"data"`
}

// Provides historical webhook event delivery information for analysis and
// debugging purposes.
type WebhookDeliveryLogResource struct {
	Attributes struct {
		// The date-time at which this log entry was created.
		CreatedAt time.Time `json:"createdAt"`

		// The success or failure status of this delivery attempt.
		DeliveryStatus interface{} `json:"deliveryStatus"`

		// Information about the request that was sent to the webhook URL.
		Request struct {
			// The payload that was sent in the request body.
			Body string `json:"body"`
		} `json:"request"`

		// Information about the response that was received from the webhook URL.
		Response *struct {
			// The payload that was received in the response body.
			Body string `json:"body"`

			// The HTTP status code received in the response.
			StatusCode int `json:"statusCode"`
		} `json:"response"`
	} `json:"attributes"`

	// The unique identifier for this log entry.
	Id            string `json:"id"`
	Relationships struct {
		WebhookEvent struct {
			Data struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `webhook-events`
				Type string `json:"type"`
			} `json:"data"`
		} `json:"webhookEvent"`
	} `json:"relationships"`

	// The type of this resource: `webhook-delivery-logs`
	Type string `json:"type"`
}

// Specifies the nature of the success or failure of a webhook delivery
// attempt to the subscribed webhook URL. The currently returned values are
// described below:
//
// - **`DELIVERED`**: The event was delivered to the webhook URL
//   successfully and a `200` response was received.
// - **`UNDELIVERABLE`**: The webhook URL was not reachable, or timed out.
// - **`BAD_RESPONSE_CODE`**: The event was delivered to the webhook URL
//   but a non-`200` response was received.
type WebhookDeliveryStatusEnum = interface{}

// Asynchronous callback request used for webhook event delivery.
type WebhookEventCallback struct {
	// The webhook event data sent to the subscribed webhook.
	Data struct {
		Attributes struct {
			// The date-time at which this event was generated.
			CreatedAt time.Time `json:"createdAt"`

			// The type of this event. This can be used to determine what action to
			// take in response to the event.
			EventType interface{} `json:"eventType"`
		} `json:"attributes"`

		// The unique identifier for this event. This will remain constant across
		// delivery retries.
		Id            string `json:"id"`
		Relationships struct {
			Transaction *struct {
				Data struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `transactions`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"transaction,omitempty"`
			Webhook struct {
				Data struct {
					// The unique identifier of the resource within its type.
					Id string `json:"id"`

					// The type of this resource: `webhooks`
					Type string `json:"type"`
				} `json:"data"`
				Links *struct {
					// The link to retrieve the related resource(s) in this relationship.
					Related string `json:"related"`
				} `json:"links,omitempty"`
			} `json:"webhook"`
		} `json:"relationships"`

		// The type of this resource: `webhook-events`
		Type string `json:"type"`
	} `json:"data"`
}

// Provides the event data used in asynchronous webhook event callbacks to
// subscribed endpoints. Webhooks events have defined `eventType`s and may
// optionally relate to other resources within the Up API.
type WebhookEventResource struct {
	Attributes struct {
		// The date-time at which this event was generated.
		CreatedAt time.Time `json:"createdAt"`

		// The type of this event. This can be used to determine what action to
		// take in response to the event.
		EventType interface{} `json:"eventType"`
	} `json:"attributes"`

	// The unique identifier for this event. This will remain constant across
	// delivery retries.
	Id            string `json:"id"`
	Relationships struct {
		Transaction *struct {
			Data struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `transactions`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"transaction,omitempty"`
		Webhook struct {
			Data struct {
				// The unique identifier of the resource within its type.
				Id string `json:"id"`

				// The type of this resource: `webhooks`
				Type string `json:"type"`
			} `json:"data"`
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"webhook"`
	} `json:"relationships"`

	// The type of this resource: `webhook-events`
	Type string `json:"type"`
}

// Specifies the type of a webhook event. This can be used to determine what
// action to take in response to the event, such as which relationships to
// expect.
type WebhookEventTypeEnum = interface{}

// Represents a webhook specified as request input.
type WebhookInputResource struct {
	Attributes struct {
		// An optional description for this webhook, up to 64 characters in
		// length.
		Description *string `json:"description"`

		// The URL that this webhook should post events to. This must be a valid
		// HTTP or HTTPS URL that does not exceed 300 characters in length.
		Url string `json:"url"`
	} `json:"attributes"`
}

// Provides information about a webhook.
type WebhookResource struct {
	Attributes struct {
		// The date-time at which this webhook was created.
		CreatedAt time.Time `json:"createdAt"`

		// An optional description that was provided at the time the webhook was
		// created.
		Description *string `json:"description"`

		// A shared secret key used to sign all webhook events sent to the
		// configured webhook URL. This field is returned only once, upon the
		// initial creation of the webhook. If lost, create a new webhook and
		// delete this webhook.
		//
		// The webhook URL receives a request with a
		// `X-Up-Authenticity-Signature` header, which is the SHA-256 HMAC of
		// the entire raw request body signed using this `secretKey`. It is
		// advised to compute and check this signature to verify the
		// authenticity of requests sent to the webhook URL. See
		// [Handling webhook events](#callback_post_webhookURL) for full
		// details.
		SecretKey *string `json:"secretKey,omitempty"`

		// The URL that this webhook is configured to `POST` events to.
		Url string `json:"url"`
	} `json:"attributes"`

	// The unique identifier for this webhook.
	Id    string `json:"id"`
	Links *struct {
		// The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty"`
	Relationships struct {
		Logs struct {
			Links *struct {
				// The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty"`
		} `json:"logs"`
	} `json:"relationships"`

	// The type of this resource: `webhooks`
	Type string `json:"type"`
}

// GetAccountsParams defines parameters for GetAccounts.
type GetAccountsParams struct {
	// The number of records to return in each page.
	PageSize *int `form:"page[size],omitempty" json:"page[size],omitempty"`

	// The type of account for which to return records. This
	// can be used to filter Savers from spending accounts.
	FilterAccountType *AccountTypeEnum `form:"filter[accountType],omitempty" json:"filter[accountType],omitempty"`

	// The account ownership structure for which to return
	// records. This can be used to filter 2Up accounts from Up
	// accounts.
	FilterOwnershipType *OwnershipTypeEnum `form:"filter[ownershipType],omitempty" json:"filter[ownershipType],omitempty"`
}

// GetAccountsAccountIdTransactionsParams defines parameters for GetAccountsAccountIdTransactions.
type GetAccountsAccountIdTransactionsParams struct {
	// The number of records to return in each page.
	PageSize *int `form:"page[size],omitempty" json:"page[size],omitempty"`

	// The transaction status for which to return records. This
	// can be used to filter `HELD` transactions from those
	// that are `SETTLED`.
	FilterStatus *TransactionStatusEnum `form:"filter[status],omitempty" json:"filter[status],omitempty"`

	// The start date-time from which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterSince *time.Time `form:"filter[since],omitempty" json:"filter[since],omitempty"`

	// The end date-time up to which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterUntil *time.Time `form:"filter[until],omitempty" json:"filter[until],omitempty"`

	// The category identifier for which to filter transactions.
	// Both parent and child categories can be filtered through
	// this parameter. Providing an invalid category identifier
	// results in a `404` response.
	FilterCategory *string `form:"filter[category],omitempty" json:"filter[category],omitempty"`

	// A transaction tag to filter for which to return records.
	// If the tag does not exist, zero records are returned and
	// a success response is given.
	FilterTag *string `form:"filter[tag],omitempty" json:"filter[tag],omitempty"`
}

// GetCategoriesParams defines parameters for GetCategories.
type GetCategoriesParams struct {
	// The unique identifier of a parent category for which to
	// return only its children. Providing an invalid category
	// identifier results in a `404` response.
	FilterParent *string `form:"filter[parent],omitempty" json:"filter[parent],omitempty"`
}

// GetTagsParams defines parameters for GetTags.
type GetTagsParams struct {
	// The number of records to return in each page.
	PageSize *int `form:"page[size],omitempty" json:"page[size],omitempty"`
}

// GetTransactionsParams defines parameters for GetTransactions.
type GetTransactionsParams struct {
	// The number of records to return in each page.
	PageSize *int `form:"page[size],omitempty" json:"page[size],omitempty"`

	// The transaction status for which to return records. This
	// can be used to filter `HELD` transactions from those
	// that are `SETTLED`.
	FilterStatus *TransactionStatusEnum `form:"filter[status],omitempty" json:"filter[status],omitempty"`

	// The start date-time from which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterSince *time.Time `form:"filter[since],omitempty" json:"filter[since],omitempty"`

	// The end date-time up to which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterUntil *time.Time `form:"filter[until],omitempty" json:"filter[until],omitempty"`

	// The category identifier for which to filter transactions.
	// Both parent and child categories can be filtered through
	// this parameter. Providing an invalid category identifier
	// results in a `404` response.
	FilterCategory *string `form:"filter[category],omitempty" json:"filter[category],omitempty"`

	// A transaction tag to filter for which to return records.
	// If the tag does not exist, zero records are returned and
	// a success response is given.
	FilterTag *string `form:"filter[tag],omitempty" json:"filter[tag],omitempty"`
}

// PatchTransactionsTransactionIdRelationshipsCategoryJSONBody defines parameters for PatchTransactionsTransactionIdRelationshipsCategory.
type PatchTransactionsTransactionIdRelationshipsCategoryJSONBody = UpdateTransactionCategoryRequest

// DeleteTransactionsTransactionIdRelationshipsTagsJSONBody defines parameters for DeleteTransactionsTransactionIdRelationshipsTags.
type DeleteTransactionsTransactionIdRelationshipsTagsJSONBody = UpdateTransactionTagsRequest

// PostTransactionsTransactionIdRelationshipsTagsJSONBody defines parameters for PostTransactionsTransactionIdRelationshipsTags.
type PostTransactionsTransactionIdRelationshipsTagsJSONBody = UpdateTransactionTagsRequest

// GetWebhooksParams defines parameters for GetWebhooks.
type GetWebhooksParams struct {
	// The number of records to return in each page.
	PageSize *int `form:"page[size],omitempty" json:"page[size],omitempty"`
}

// PostWebhooksJSONBody defines parameters for PostWebhooks.
type PostWebhooksJSONBody = CreateWebhookRequest

// GetWebhooksWebhookIdLogsParams defines parameters for GetWebhooksWebhookIdLogs.
type GetWebhooksWebhookIdLogsParams struct {
	// The number of records to return in each page.
	PageSize *int `form:"page[size],omitempty" json:"page[size],omitempty"`
}

// PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody defines body for PatchTransactionsTransactionIdRelationshipsCategory for application/json ContentType.
type PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody = PatchTransactionsTransactionIdRelationshipsCategoryJSONBody

// DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody defines body for DeleteTransactionsTransactionIdRelationshipsTags for application/json ContentType.
type DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody = DeleteTransactionsTransactionIdRelationshipsTagsJSONBody

// PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody defines body for PostTransactionsTransactionIdRelationshipsTags for application/json ContentType.
type PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody = PostTransactionsTransactionIdRelationshipsTagsJSONBody

// PostWebhooksJSONRequestBody defines body for PostWebhooks for application/json ContentType.
type PostWebhooksJSONRequestBody = PostWebhooksJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccounts request
	GetAccounts(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountsAccountIdTransactions request
	GetAccountsAccountIdTransactions(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountsId request
	GetAccountsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategories request
	GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoriesId request
	GetCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactions request
	GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsId request
	GetTransactionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchTransactionsTransactionIdRelationshipsCategory request with any body
	PatchTransactionsTransactionIdRelationshipsCategoryWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchTransactionsTransactionIdRelationshipsCategory(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransactionsTransactionIdRelationshipsTags request with any body
	DeleteTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransactionsTransactionIdRelationshipsTags request with any body
	PostTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUtilPing request
	GetUtilPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhooks request
	GetWebhooks(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWebhooks request with any body
	PostWebhooksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWebhooks(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhooksId request
	DeleteWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhooksId request
	GetWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhooksWebhookIdLogs request
	GetWebhooksWebhookIdLogs(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWebhooksWebhookIdPing request
	PostWebhooksWebhookIdPing(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccounts(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountsAccountIdTransactions(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsAccountIdTransactionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTransactionsTransactionIdRelationshipsCategoryWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTransactionsTransactionIdRelationshipsCategory(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTransactionsTransactionIdRelationshipsCategoryRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionsTransactionIdRelationshipsTagsRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionsTransactionIdRelationshipsTagsRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUtilPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUtilPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhooks(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooks(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhooksIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhooksIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhooksWebhookIdLogs(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhooksWebhookIdLogsRequest(c.Server, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooksWebhookIdPing(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksWebhookIdPingRequest(c.Server, webhookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountsRequest generates requests for GetAccounts
func NewGetAccountsRequest(server string, params *GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterAccountType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[accountType]", runtime.ParamLocationQuery, *params.FilterAccountType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterOwnershipType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[ownershipType]", runtime.ParamLocationQuery, *params.FilterOwnershipType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountsAccountIdTransactionsRequest generates requests for GetAccountsAccountIdTransactions
func NewGetAccountsAccountIdTransactionsRequest(server string, accountId string, params *GetAccountsAccountIdTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[status]", runtime.ParamLocationQuery, *params.FilterStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSince != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[since]", runtime.ParamLocationQuery, *params.FilterSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterUntil != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[until]", runtime.ParamLocationQuery, *params.FilterUntil); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterCategory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[category]", runtime.ParamLocationQuery, *params.FilterCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[tag]", runtime.ParamLocationQuery, *params.FilterTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountsIdRequest generates requests for GetAccountsId
func NewGetAccountsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesRequest generates requests for GetCategories
func NewGetCategoriesRequest(server string, params *GetCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FilterParent != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[parent]", runtime.ParamLocationQuery, *params.FilterParent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesIdRequest generates requests for GetCategoriesId
func NewGetCategoriesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string, params *GetTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionsRequest generates requests for GetTransactions
func NewGetTransactionsRequest(server string, params *GetTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[status]", runtime.ParamLocationQuery, *params.FilterStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSince != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[since]", runtime.ParamLocationQuery, *params.FilterSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterUntil != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[until]", runtime.ParamLocationQuery, *params.FilterUntil); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterCategory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[category]", runtime.ParamLocationQuery, *params.FilterCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[tag]", runtime.ParamLocationQuery, *params.FilterTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionsIdRequest generates requests for GetTransactionsId
func NewGetTransactionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchTransactionsTransactionIdRelationshipsCategoryRequest calls the generic PatchTransactionsTransactionIdRelationshipsCategory builder with application/json body
func NewPatchTransactionsTransactionIdRelationshipsCategoryRequest(server string, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody generates requests for PatchTransactionsTransactionIdRelationshipsCategory with any type of body
func NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/relationships/category", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTransactionsTransactionIdRelationshipsTagsRequest calls the generic DeleteTransactionsTransactionIdRelationshipsTags builder with application/json body
func NewDeleteTransactionsTransactionIdRelationshipsTagsRequest(server string, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody generates requests for DeleteTransactionsTransactionIdRelationshipsTags with any type of body
func NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/relationships/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransactionsTransactionIdRelationshipsTagsRequest calls the generic PostTransactionsTransactionIdRelationshipsTags builder with application/json body
func NewPostTransactionsTransactionIdRelationshipsTagsRequest(server string, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody generates requests for PostTransactionsTransactionIdRelationshipsTags with any type of body
func NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/relationships/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUtilPingRequest generates requests for GetUtilPing
func NewGetUtilPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/util/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhooksRequest generates requests for GetWebhooks
func NewGetWebhooksRequest(server string, params *GetWebhooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWebhooksRequest calls the generic PostWebhooks builder with application/json body
func NewPostWebhooksRequest(server string, body PostWebhooksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWebhooksRequestWithBody(server, "application/json", bodyReader)
}

// NewPostWebhooksRequestWithBody generates requests for PostWebhooks with any type of body
func NewPostWebhooksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhooksIdRequest generates requests for DeleteWebhooksId
func NewDeleteWebhooksIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhooksIdRequest generates requests for GetWebhooksId
func NewGetWebhooksIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhooksWebhookIdLogsRequest generates requests for GetWebhooksWebhookIdLogs
func NewGetWebhooksWebhookIdLogsRequest(server string, webhookId string, params *GetWebhooksWebhookIdLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWebhooksWebhookIdPingRequest generates requests for PostWebhooksWebhookIdPing
func NewPostWebhooksWebhookIdPingRequest(server string, webhookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/ping", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccounts request
	GetAccountsWithResponse(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error)

	// GetAccountsAccountIdTransactions request
	GetAccountsAccountIdTransactionsWithResponse(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*GetAccountsAccountIdTransactionsResponse, error)

	// GetAccountsId request
	GetAccountsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccountsIdResponse, error)

	// GetCategories request
	GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error)

	// GetCategoriesId request
	GetCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCategoriesIdResponse, error)

	// GetTags request
	GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// GetTransactions request
	GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error)

	// GetTransactionsId request
	GetTransactionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionsIdResponse, error)

	// PatchTransactionsTransactionIdRelationshipsCategory request with any body
	PatchTransactionsTransactionIdRelationshipsCategoryWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error)

	PatchTransactionsTransactionIdRelationshipsCategoryWithResponse(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error)

	// DeleteTransactionsTransactionIdRelationshipsTags request with any body
	DeleteTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error)

	DeleteTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error)

	// PostTransactionsTransactionIdRelationshipsTags request with any body
	PostTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error)

	PostTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error)

	// GetUtilPing request
	GetUtilPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUtilPingResponse, error)

	// GetWebhooks request
	GetWebhooksWithResponse(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*GetWebhooksResponse, error)

	// PostWebhooks request with any body
	PostWebhooksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	PostWebhooksWithResponse(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	// DeleteWebhooksId request
	DeleteWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteWebhooksIdResponse, error)

	// GetWebhooksId request
	GetWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetWebhooksIdResponse, error)

	// GetWebhooksWebhookIdLogs request
	GetWebhooksWebhookIdLogsWithResponse(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*GetWebhooksWebhookIdLogsResponse, error)

	// PostWebhooksWebhookIdPing request
	PostWebhooksWebhookIdPingWithResponse(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*PostWebhooksWebhookIdPingResponse, error)
}

type GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAccountsResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountsAccountIdTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsAccountIdTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsAccountIdTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccountResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCategoriesResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCategoryResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTagsResponse
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTransactionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchTransactionsTransactionIdRelationshipsCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PatchTransactionsTransactionIdRelationshipsCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchTransactionsTransactionIdRelationshipsCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionsTransactionIdRelationshipsTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionsTransactionIdRelationshipsTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionsTransactionIdRelationshipsTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransactionsTransactionIdRelationshipsTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostTransactionsTransactionIdRelationshipsTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransactionsTransactionIdRelationshipsTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUtilPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PingResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUtilPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUtilPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWebhooksResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateWebhookResponse
}

// Status returns HTTPResponse.Status
func (r PostWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhooksIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWebhooksIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhooksIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhooksIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWebhookResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhooksIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhooksIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhooksWebhookIdLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWebhookDeliveryLogsResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhooksWebhookIdLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhooksWebhookIdLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWebhooksWebhookIdPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhookEventCallback
}

// Status returns HTTPResponse.Status
func (r PostWebhooksWebhookIdPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWebhooksWebhookIdPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountsWithResponse request returning *GetAccountsResponse
func (c *ClientWithResponses) GetAccountsWithResponse(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error) {
	rsp, err := c.GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsResponse(rsp)
}

// GetAccountsAccountIdTransactionsWithResponse request returning *GetAccountsAccountIdTransactionsResponse
func (c *ClientWithResponses) GetAccountsAccountIdTransactionsWithResponse(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*GetAccountsAccountIdTransactionsResponse, error) {
	rsp, err := c.GetAccountsAccountIdTransactions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsAccountIdTransactionsResponse(rsp)
}

// GetAccountsIdWithResponse request returning *GetAccountsIdResponse
func (c *ClientWithResponses) GetAccountsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccountsIdResponse, error) {
	rsp, err := c.GetAccountsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsIdResponse(rsp)
}

// GetCategoriesWithResponse request returning *GetCategoriesResponse
func (c *ClientWithResponses) GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error) {
	rsp, err := c.GetCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesResponse(rsp)
}

// GetCategoriesIdWithResponse request returning *GetCategoriesIdResponse
func (c *ClientWithResponses) GetCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCategoriesIdResponse, error) {
	rsp, err := c.GetCategoriesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesIdResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// GetTransactionsWithResponse request returning *GetTransactionsResponse
func (c *ClientWithResponses) GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error) {
	rsp, err := c.GetTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsResponse(rsp)
}

// GetTransactionsIdWithResponse request returning *GetTransactionsIdResponse
func (c *ClientWithResponses) GetTransactionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionsIdResponse, error) {
	rsp, err := c.GetTransactionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsIdResponse(rsp)
}

// PatchTransactionsTransactionIdRelationshipsCategoryWithBodyWithResponse request with arbitrary body returning *PatchTransactionsTransactionIdRelationshipsCategoryResponse
func (c *ClientWithResponses) PatchTransactionsTransactionIdRelationshipsCategoryWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error) {
	rsp, err := c.PatchTransactionsTransactionIdRelationshipsCategoryWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse(rsp)
}

func (c *ClientWithResponses) PatchTransactionsTransactionIdRelationshipsCategoryWithResponse(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error) {
	rsp, err := c.PatchTransactionsTransactionIdRelationshipsCategory(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse(rsp)
}

// DeleteTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse request with arbitrary body returning *DeleteTransactionsTransactionIdRelationshipsTagsResponse
func (c *ClientWithResponses) DeleteTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.DeleteTransactionsTransactionIdRelationshipsTagsWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.DeleteTransactionsTransactionIdRelationshipsTags(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

// PostTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse request with arbitrary body returning *PostTransactionsTransactionIdRelationshipsTagsResponse
func (c *ClientWithResponses) PostTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.PostTransactionsTransactionIdRelationshipsTagsWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

func (c *ClientWithResponses) PostTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.PostTransactionsTransactionIdRelationshipsTags(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

// GetUtilPingWithResponse request returning *GetUtilPingResponse
func (c *ClientWithResponses) GetUtilPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUtilPingResponse, error) {
	rsp, err := c.GetUtilPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUtilPingResponse(rsp)
}

// GetWebhooksWithResponse request returning *GetWebhooksResponse
func (c *ClientWithResponses) GetWebhooksWithResponse(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*GetWebhooksResponse, error) {
	rsp, err := c.GetWebhooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhooksResponse(rsp)
}

// PostWebhooksWithBodyWithResponse request with arbitrary body returning *PostWebhooksResponse
func (c *ClientWithResponses) PostWebhooksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

func (c *ClientWithResponses) PostWebhooksWithResponse(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

// DeleteWebhooksIdWithResponse request returning *DeleteWebhooksIdResponse
func (c *ClientWithResponses) DeleteWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteWebhooksIdResponse, error) {
	rsp, err := c.DeleteWebhooksId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhooksIdResponse(rsp)
}

// GetWebhooksIdWithResponse request returning *GetWebhooksIdResponse
func (c *ClientWithResponses) GetWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetWebhooksIdResponse, error) {
	rsp, err := c.GetWebhooksId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhooksIdResponse(rsp)
}

// GetWebhooksWebhookIdLogsWithResponse request returning *GetWebhooksWebhookIdLogsResponse
func (c *ClientWithResponses) GetWebhooksWebhookIdLogsWithResponse(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*GetWebhooksWebhookIdLogsResponse, error) {
	rsp, err := c.GetWebhooksWebhookIdLogs(ctx, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhooksWebhookIdLogsResponse(rsp)
}

// PostWebhooksWebhookIdPingWithResponse request returning *PostWebhooksWebhookIdPingResponse
func (c *ClientWithResponses) PostWebhooksWebhookIdPingWithResponse(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*PostWebhooksWebhookIdPingResponse, error) {
	rsp, err := c.PostWebhooksWebhookIdPing(ctx, webhookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksWebhookIdPingResponse(rsp)
}

// ParseGetAccountsResponse parses an HTTP response from a GetAccountsWithResponse call
func ParseGetAccountsResponse(rsp *http.Response) (*GetAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAccountsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccountsAccountIdTransactionsResponse parses an HTTP response from a GetAccountsAccountIdTransactionsWithResponse call
func ParseGetAccountsAccountIdTransactionsResponse(rsp *http.Response) (*GetAccountsAccountIdTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsAccountIdTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccountsIdResponse parses an HTTP response from a GetAccountsIdWithResponse call
func ParseGetAccountsIdResponse(rsp *http.Response) (*GetAccountsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCategoriesResponse parses an HTTP response from a GetCategoriesWithResponse call
func ParseGetCategoriesResponse(rsp *http.Response) (*GetCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCategoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCategoriesIdResponse parses an HTTP response from a GetCategoriesIdWithResponse call
func ParseGetCategoriesIdResponse(rsp *http.Response) (*GetCategoriesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTagsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTransactionsResponse parses an HTTP response from a GetTransactionsWithResponse call
func ParseGetTransactionsResponse(rsp *http.Response) (*GetTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTransactionsIdResponse parses an HTTP response from a GetTransactionsIdWithResponse call
func ParseGetTransactionsIdResponse(rsp *http.Response) (*GetTransactionsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse parses an HTTP response from a PatchTransactionsTransactionIdRelationshipsCategoryWithResponse call
func ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse(rsp *http.Response) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchTransactionsTransactionIdRelationshipsCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse parses an HTTP response from a DeleteTransactionsTransactionIdRelationshipsTagsWithResponse call
func ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse(rsp *http.Response) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionsTransactionIdRelationshipsTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostTransactionsTransactionIdRelationshipsTagsResponse parses an HTTP response from a PostTransactionsTransactionIdRelationshipsTagsWithResponse call
func ParsePostTransactionsTransactionIdRelationshipsTagsResponse(rsp *http.Response) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransactionsTransactionIdRelationshipsTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUtilPingResponse parses an HTTP response from a GetUtilPingWithResponse call
func ParseGetUtilPingResponse(rsp *http.Response) (*GetUtilPingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUtilPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetWebhooksResponse parses an HTTP response from a GetWebhooksWithResponse call
func ParseGetWebhooksResponse(rsp *http.Response) (*GetWebhooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWebhooksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostWebhooksResponse parses an HTTP response from a PostWebhooksWithResponse call
func ParsePostWebhooksResponse(rsp *http.Response) (*PostWebhooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateWebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteWebhooksIdResponse parses an HTTP response from a DeleteWebhooksIdWithResponse call
func ParseDeleteWebhooksIdResponse(rsp *http.Response) (*DeleteWebhooksIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhooksIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWebhooksIdResponse parses an HTTP response from a GetWebhooksIdWithResponse call
func ParseGetWebhooksIdResponse(rsp *http.Response) (*GetWebhooksIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhooksIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWebhooksWebhookIdLogsResponse parses an HTTP response from a GetWebhooksWebhookIdLogsWithResponse call
func ParseGetWebhooksWebhookIdLogsResponse(rsp *http.Response) (*GetWebhooksWebhookIdLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhooksWebhookIdLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWebhookDeliveryLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostWebhooksWebhookIdPingResponse parses an HTTP response from a PostWebhooksWebhookIdPingWithResponse call
func ParsePostWebhooksWebhookIdPingResponse(rsp *http.Response) (*PostWebhooksWebhookIdPingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWebhooksWebhookIdPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhookEventCallback
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}
